#!/usr/bin/env -S uv run
"""Stub generation processor for creating type stub files."""

import ast
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, ClassVar, Sequence

from loguru import logger

from ..errors import ErrorCode, StubGenerationError
from ..types.type_system import TypeInfo, TypeRegistry
from ..utils.ast_utils import attach_parents, truncate_literal, TruncationConfig


@dataclass
class StubConfig:
    """Configuration for stub generation."""

    # Output settings
    line_length: int = 88
    sort_imports: bool = True
    add_header: bool = True
    header_template: str = (
        "# Generated by pystubnik\n# Do not edit this file directly\n\n"
    )

    # Content settings
    include_docstrings: bool = True
    include_private: bool = False
    include_type_comments: bool = True
    infer_property_types: bool = True
    export_less: bool = False

    # Truncation settings
    truncation: TruncationConfig = field(default_factory=TruncationConfig)


class StubGenerator:
    """Generate type stubs from Python source code."""

    # Common import patterns to preserve
    ESSENTIAL_IMPORTS: ClassVar[set[str]] = {
        "typing",
        "dataclasses",
        "enum",
        "abc",
        "contextlib",
        "pathlib",
        "collections.abc",
    }

    def __init__(
        self,
        config: StubConfig | None = None,
        type_registry: TypeRegistry | None = None,
    ) -> None:
        """Initialize the stub generator.

        Args:
            config: Configuration for stub generation
            type_registry: Registry for type resolution
        """
        self.config = config or StubConfig()
        self.type_registry = type_registry or TypeRegistry()

    def generate_stub(self, source_path: Path, tree: ast.AST | None = None) -> str:
        """Generate a type stub for a Python source file.

        Args:
            source_path: Path to the source file
            tree: Optional pre-parsed AST

        Returns:
            Generated stub content

        Raises:
            StubGenerationError: If stub generation fails
        """
        try:
            # Parse source if not provided
            if tree is None:
                with source_path.open() as f:
                    tree = ast.parse(f.read(), filename=str(source_path))

            # Attach parent references for better context
            attach_parents(tree)

            # Process the AST
            processed = self._process_module(tree)

            # Generate stub content
            return self._generate_content(processed)

        except Exception as e:
            raise StubGenerationError(
                f"Failed to generate stub for {source_path}: {e}",
                ErrorCode.AST_TRANSFORM_ERROR,
                source=str(source_path),
            ) from e

    def _process_module(self, node: ast.Module) -> ast.Module:
        """Process a module AST for stub generation.

        Args:
            node: Module AST to process

        Returns:
            Processed module AST
        """
        # Create a new module for the stub
        stub = ast.Module(body=[], type_ignores=[])

        # Process imports first
        imports = []
        for child in node.body:
            if isinstance(child, (ast.Import, ast.ImportFrom)):
                if self._should_keep_import(child):
                    imports.append(child)

        # Process remaining nodes
        definitions = []
        for child in node.body:
            if isinstance(child, (ast.Import, ast.ImportFrom)):
                continue
            if processed := self._process_node(child):
                definitions.append(processed)

        # Combine and sort imports
        if self.config.sort_imports:
            imports.sort(key=self._import_sort_key)

        # Add header if configured
        if self.config.add_header:
            header = ast.Expr(value=ast.Constant(value=self.config.header_template))
            stub.body.append(header)

        # Combine all parts
        stub.body.extend(imports)
        if imports and definitions:
            # Add blank line between imports and definitions
            stub.body.append(ast.Expr(value=ast.Constant(value="")))
        stub.body.extend(definitions)

        return stub

    def _process_node(self, node: ast.AST) -> ast.AST | None:
        """Process a single AST node for stub generation.

        Args:
            node: AST node to process

        Returns:
            Processed node or None if it should be excluded
        """
        match node:
            case ast.ClassDef():
                return self._process_class(node)
            case ast.FunctionDef() | ast.AsyncFunctionDef():
                return self._process_function(node)
            case ast.AnnAssign() | ast.Assign():
                return self._process_assignment(node)
            case _:
                return None

    def _process_class(self, node: ast.ClassDef) -> ast.ClassDef | None:
        """Process a class definition for stub generation.

        Args:
            node: Class definition to process

        Returns:
            Processed class definition or None if it should be excluded
        """
        if not self.config.include_private and node.name.startswith("_"):
            return None

        # Create new class with same name and bases
        stub_class = ast.ClassDef(
            name=node.name,
            bases=node.bases,
            keywords=node.keywords,
            body=[],
            decorator_list=node.decorator_list,
            type_params=[],  # For Python 3.12+
        )

        # Preserve docstring if configured
        if self.config.include_docstrings:
            docstring = ast.get_docstring(node)
            if docstring:
                stub_class.body.append(ast.Expr(value=ast.Constant(value=docstring)))

        # Process class body
        for child in node.body:
            if processed := self._process_node(child):
                stub_class.body.append(processed)

        return stub_class

    def _process_function(
        self, node: ast.FunctionDef | ast.AsyncFunctionDef
    ) -> ast.FunctionDef | ast.AsyncFunctionDef | None:
        """Process a function definition for stub generation.

        Args:
            node: Function definition to process

        Returns:
            Processed function definition or None if it should be excluded
        """
        if not self.config.include_private and node.name.startswith("_"):
            return None

        # Create new function with same signature
        stub_func = type(node)(
            name=node.name,
            args=node.args,
            returns=node.returns,
            type_params=[],  # For Python 3.12+
            body=[ast.Expr(value=ast.Constant(value=...))],  # Use ellipsis for body
            decorator_list=node.decorator_list,
        )

        # Preserve docstring if configured
        if self.config.include_docstrings:
            docstring = ast.get_docstring(node)
            if docstring:
                stub_func.body.insert(0, ast.Expr(value=ast.Constant(value=docstring)))

        return stub_func

    def _process_assignment(self, node: ast.AnnAssign | ast.Assign) -> ast.AST | None:
        """Process an assignment for stub generation.

        Args:
            node: Assignment to process

        Returns:
            Processed assignment or None if it should be excluded
        """
        match node:
            case ast.AnnAssign():
                # Preserve annotated assignments
                return node
            case ast.Assign(targets=[ast.Name(id=name)]):
                # Only keep module-level assignments of constants
                if (
                    isinstance(node.value, ast.Constant)
                    and not name.startswith("_")
                    or name.isupper()
                ):
                    return ast.AnnAssign(
                        target=node.targets[0],
                        annotation=ast.Name(id=type(node.value.value).__name__),
                        value=truncate_literal(node.value, self.config.truncation),
                        simple=1,
                    )
        return None

    def _should_keep_import(self, node: ast.Import | ast.ImportFrom) -> bool:
        """Check if an import should be kept in the stub.

        Args:
            node: Import node to check

        Returns:
            True if the import should be kept
        """
        if isinstance(node, ast.ImportFrom):
            return node.module in self.ESSENTIAL_IMPORTS or any(
                name.name.isupper() for name in node.names
            )
        return any(
            name.name in self.ESSENTIAL_IMPORTS
            or name.name.split(".")[0] in self.ESSENTIAL_IMPORTS
            for name in node.names
        )

    def _import_sort_key(self, node: ast.Import | ast.ImportFrom) -> tuple[int, str]:
        """Get sort key for import statements.

        Args:
            node: Import node to sort

        Returns:
            Tuple of (import type, module name) for sorting
        """
        if isinstance(node, ast.ImportFrom):
            return (1, node.module or "")
        return (0, node.names[0].name)

    def _generate_content(self, node: ast.AST) -> str:
        """Generate stub content from processed AST.

        Args:
            node: Processed AST

        Returns:
            Generated stub content
        """
        return ast.unparse(node)
