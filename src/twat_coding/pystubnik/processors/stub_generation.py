#!/usr/bin/env -S uv run
"""Stub generation processor for creating type stub files."""

import ast
from dataclasses import dataclass, field
from pathlib import Path
from typing import ClassVar, cast

from ..errors import ErrorCode, StubGenerationError
from ..types.type_system import TypeRegistry
from ..utils.ast_utils import TruncationConfig, attach_parents


@dataclass
class StubConfig:
    """Configuration for stub generation."""

    # Output settings
    line_length: int = 88
    sort_imports: bool = True
    add_header: bool = True
    header_template: str = (
        "# Generated by pystubnik\n# Do not edit this file directly\n\n"
    )

    # Content settings
    include_docstrings: bool = True
    include_private: bool = False
    include_type_comments: bool = True
    infer_property_types: bool = True
    export_less: bool = False

    # Truncation settings
    truncation: TruncationConfig = field(default_factory=TruncationConfig)


class StubGenerator:
    """Generate type stubs from Python source code."""

    # Common import patterns to preserve
    ESSENTIAL_IMPORTS: ClassVar[set[str]] = {
        "typing",
        "dataclasses",
        "enum",
        "abc",
        "contextlib",
        "pathlib",
        "collections.abc",
    }

    def __init__(
        self,
        config: StubConfig | None = None,
        type_registry: TypeRegistry | None = None,
    ) -> None:
        """Initialize the stub generator.

        Args:
            config: Configuration for stub generation
            type_registry: Registry for type resolution
        """
        self.config = config or StubConfig()
        self.type_registry = type_registry or TypeRegistry()

    def generate_stub(self, source_path: Path, tree: ast.AST | None = None) -> str:
        """Generate a type stub for a Python source file.

        Args:
            source_path: Path to the source file
            tree: Optional pre-parsed AST

        Returns:
            Generated stub content

        Raises:
            StubGenerationError: If stub generation fails
        """
        try:
            # Parse source if not provided
            if tree is None:
                with source_path.open() as f:
                    tree = ast.parse(f.read(), filename=str(source_path))

            # Attach parent references for better context
            attach_parents(tree)

            # Process the AST
            if not isinstance(tree, ast.Module):
                raise StubGenerationError(
                    "Expected Module AST node",
                    ErrorCode.AST_PARSE_ERROR,
                    source=str(source_path),
                )
            processed = self._process_module(tree)

            # Generate stub content
            return self._generate_content(processed)

        except Exception as e:
            raise StubGenerationError(
                f"Failed to generate stub for {source_path}: {e}",
                ErrorCode.AST_TRANSFORM_ERROR,
                source=str(source_path),
            ) from e

    def _process_module(self, node: ast.Module) -> ast.Module:
        """Process a module AST for stub generation.

        Args:
            node: Module AST to process

        Returns:
            Processed module AST
        """
        # Create a new module for the stub
        stub = ast.Module(body=[], type_ignores=[])

        # Process imports and definitions
        imports = self._collect_imports(node)
        definitions = self._collect_definitions(node)

        # Build the stub body
        stub.body = self._build_stub_body(imports, definitions)

        return stub

    def _collect_imports(self, node: ast.Module) -> list[ast.Import | ast.ImportFrom]:
        """Collect and process import statements.

        Args:
            node: Module AST to process

        Returns:
            List of processed import statements
        """
        imports = [
            child
            for child in node.body
            if isinstance(child, ast.Import | ast.ImportFrom)
            and self._should_keep_import(child)
        ]

        if self.config.sort_imports and imports:
            # Sort imports by module name
            imports_with_keys = [
                (self._import_sort_key(cast(ast.Import | ast.ImportFrom, imp)), imp)
                for imp in imports
            ]
            imports_with_keys.sort(key=lambda x: x[0])
            imports = [imp for _, imp in imports_with_keys]

        return imports

    def _collect_definitions(self, node: ast.Module) -> list[ast.stmt]:
        """Collect and process module definitions.

        Args:
            node: Module AST to process

        Returns:
            List of processed definitions
        """
        definitions = []
        for child in node.body:
            if not isinstance(child, ast.Import | ast.ImportFrom):
                if processed := self._process_node(child):
                    if isinstance(processed, ast.stmt):
                        definitions.append(processed)
        return definitions

    def _build_stub_body(
        self,
        imports: list[ast.Import | ast.ImportFrom],
        definitions: list[ast.stmt],
    ) -> list[ast.stmt]:
        """Build the final stub body from components.

        Args:
            imports: List of processed import statements
            definitions: List of processed definitions

        Returns:
            Complete list of statements for the stub body
        """
        body: list[ast.stmt] = []

        # Add header if configured
        if self.config.add_header:
            header = ast.Expr(value=ast.Constant(value=self.config.header_template))
            body.append(header)

        # Add imports
        body.extend(imports)

        # Add separator if needed
        if imports and definitions:
            body.append(ast.Expr(value=ast.Constant(value="")))

        # Add definitions
        body.extend(definitions)

        return body

    def _process_node(self, node: ast.AST) -> ast.stmt | None:
        """Process a single AST node for stub generation.

        Args:
            node: AST node to process

        Returns:
            Processed node or None if it should be excluded
        """
        match node:
            case ast.ClassDef():
                return self._process_class(node)
            case ast.FunctionDef() | ast.AsyncFunctionDef():
                return self._process_function(node)
            case ast.AnnAssign() | ast.Assign():
                return self._process_assignment(node)
            case _:
                return None

    def _process_class(self, node: ast.ClassDef) -> ast.ClassDef | None:
        """Process a class definition for stub generation.

        Args:
            node: Class definition to process

        Returns:
            Processed class definition or None if it should be excluded
        """
        if not self.config.include_private and node.name.startswith("_"):
            return None

        # Create new class with same name and bases
        stub_class = ast.ClassDef(
            name=node.name,
            bases=node.bases,
            keywords=node.keywords,
            body=[],
            decorator_list=node.decorator_list,
            type_params=[],  # For Python 3.12+
        )

        # Preserve docstring if configured
        if self.config.include_docstrings:
            docstring = ast.get_docstring(node)
            if docstring:
                stub_class.body.append(ast.Expr(value=ast.Constant(value=docstring)))

        # Process class body
        for child in node.body:
            if processed := self._process_node(child):
                stub_class.body.append(processed)

        return stub_class

    def _process_function(
        self, node: ast.FunctionDef | ast.AsyncFunctionDef
    ) -> ast.FunctionDef | ast.AsyncFunctionDef | None:
        """Process a function definition for stub generation.

        Args:
            node: Function definition to process

        Returns:
            Processed function definition or None if it should be excluded
        """
        if not self.config.include_private and node.name.startswith("_"):
            return None

        # Create new function with same signature
        stub_func = type(node)(
            name=node.name,
            args=node.args,
            returns=node.returns,
            type_params=[],  # For Python 3.12+
            body=[ast.Expr(value=ast.Constant(value=...))],  # Use ellipsis for body
            decorator_list=node.decorator_list,
        )

        # Preserve docstring if configured
        if self.config.include_docstrings:
            docstring = ast.get_docstring(node)
            if docstring:
                stub_func.body.insert(0, ast.Expr(value=ast.Constant(value=docstring)))

        return stub_func

    def _process_assignment(self, node: ast.AnnAssign | ast.Assign) -> ast.stmt | None:
        """Process an assignment for stub generation.

        Args:
            node: Assignment to process

        Returns:
            Processed assignment or None if it should be excluded
        """
        match node:
            case ast.AnnAssign():
                # Preserve annotated assignments
                return node
            case ast.Assign(
                targets=[ast.Name() as name_node], value=ast.Constant() as value
            ):
                # Only keep module-level assignments of constants
                if not name_node.id.startswith("_") or name_node.id.isupper():
                    return ast.AnnAssign(
                        target=name_node,
                        annotation=ast.Name(id=type(value.value).__name__),
                        value=value,
                        simple=1,
                    )
        return None

    def _should_keep_import(self, node: ast.Import | ast.ImportFrom) -> bool:
        """Check if an import should be kept in the stub.

        Args:
            node: Import node to check

        Returns:
            True if the import should be kept
        """
        if isinstance(node, ast.ImportFrom):
            return node.module in self.ESSENTIAL_IMPORTS or any(
                name.name.isupper() for name in node.names
            )
        return any(
            name.name in self.ESSENTIAL_IMPORTS
            or name.name.split(".")[0] in self.ESSENTIAL_IMPORTS
            for name in node.names
        )

    def _import_sort_key(self, node: ast.Import | ast.ImportFrom) -> tuple[int, str]:
        """Get sort key for import statements.

        Args:
            node: Import node to sort

        Returns:
            Tuple of (import type, module name) for sorting
        """
        if isinstance(node, ast.ImportFrom):
            return (1, node.module or "")
        return (0, node.names[0].name)

    def _generate_content(self, node: ast.Module) -> str:
        """Generate stub content from processed AST.

        Args:
            node: Processed AST

        Returns:
            Generated stub content
        """
        return ast.unparse(node)
